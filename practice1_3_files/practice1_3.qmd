---
title: Data Visualization Using `plotnine`
jupyter: python3
format:
  html: 
    embed-resources: true
---

The Palmer Penguins dataset had a variety of column types with which to explore some nice visualizations. The `mtcars` dataset is another popular dataset for doing some simple data work, but does not contain the same types of variables.

Run the following code to load the `mtcars` dataset and explore the observations and variables contained within. To learn more about this dataset check out [this site](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/mtcars.html)


```{python}
!pip install plotnine
```

```{python}
!pip install statsmodels
```

```{python}
!pip install pandas
```

```{python}
import statsmodels.api as sm
import pandas as pd

mtcars = sm.datasets.get_rdataset("mtcars", "datasets", cache=True).data
df = pd.DataFrame(mtcars)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
df
```

The statement "the `mtcars` dataset does not contain the same types of variables as the penguins dataset" is a little true and a little false. There are no variables that contain text values, BUT there are variables that it makes sense to consider categorical variables. In most situations, it makes sense to treat the values of categorical variables as text values instead of numeric values.

Use the `astype()` method to convert the categorical variables of the `mtcars` (df) dataset to have text values in the code chunk below. We've done one for you!

```{python}
df["am"] = df["am"].astype(str)


# Convert the other variables below
df["vs"] = df["vs"].astype(str)
df["gear"] = df["gear"].astype(str)
df["carb"] = df["carb"].astype(str)
df['cyl'] = df['cyl'].astype(str)
```

If you print out your new dataset, is it clear that the variables have been converted to text values? If so, how can you tell?

It should also be clear by how `plotnine` treats these variables.

1. Create side-by-side boxplots of the `mpg` variable by the different values of the `am` variable. What happens if you convert the `am` variable back to float values and then try to create this same plot? Explain the differences between the two plots.

2. Create overlaid histograms of the `hp` variable for the different values of the `cyl` variable. What happens if you convert the `cyl` variable back to float values and then try to create this same plot? Explain the differences between the two plots.

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 497}
# Create plot for (1) here
from plotnine import ggplot, aes, geom_boxplot
from plotnine import facet_wrap
(ggplot(df,
        aes(
            x='am',
            y='mpg',
            fill='am'
))
        + geom_boxplot()
)
```

```{python}
df["am"] = df["am"].astype(float)
df["vs"] = df["vs"].astype(float)
df["gear"] = df["gear"].astype(float)
df["carb"] = df["carb"].astype(float)
df['cyl'] = df['cyl'].astype(float)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 497}
# Create plot for (1) here
from plotnine import ggplot, aes, geom_boxplot
from plotnine import facet_wrap
(ggplot(df,
        aes(
            x='am',
            y='mpg',
            fill='am'
))
        + geom_boxplot()
)
```

When i converted the variable to float, the plotnine functions could not recognise the numebr as categories and treatd them as numbers(which can be calculated) that is why it couldn't create a graph differentiating the different values of "am" variable an thus the side-by-side plot is not shown.

```{python}
#convertind the variables back to string format
df["am"] = df["am"].astype(str)
df["vs"] = df["vs"].astype(str)
df["gear"] = df["gear"].astype(str)
df["carb"] = df["carb"].astype(str)
df['cyl'] = df['cyl'].astype(str)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 535}
# Create plot for (2) here
from plotnine import geom_histogram
(ggplot(df,
aes(
  x = "hp",
  fill = "cyl"
))
+ geom_histogram()
)
```

```{python}
#converting the variable to float type
df["am"] = df["am"].astype(float)
df["vs"] = df["vs"].astype(float)
df["gear"] = df["gear"].astype(float)
df["carb"] = df["carb"].astype(float)
df['cyl'] = df['cyl'].astype(float)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 535}
from plotnine import geom_histogram
(ggplot(df,
aes(
  x = "hp",
  fill = "cyl"
))
+ geom_histogram()
)
```

When the variable type is string for "cyl", the geom_histogram function is able to indentify the categories and is able to fill the histogram with different categories of "cyl", but when the values are converted into float, the function is unable to identify the categories and spits out a histogram with just counts of "hp" without categorised by the "cyl" variable.

Some of these variables, like the `cyl` variable, have numeric values that actually make sense as numbers (i.e. the number of cylinders in the engine). However, it doesn't make the most sense to "do math" with this type of variable (e.g. take averages and such) because there are so few different value this can take on AND they're an explicit choice made by the car manufacturer. So, it makes more sense to treat the `cyl` variable as a categorical variable despite it having numeric values.

You will need to keep these kinds of nuances about data in mind as you work with an increasing variety and richness of data, and do more complex things with them.

Choose 3 new `geometries` from the [data-to-viz website](https://www.data-to-viz.com/) for graphs that you'd like to explore using the `mtcars` dataset, and then create those graphs!

```{python}
# Create plot with first new geometry here
#first converting all the possible categorial variables in string type
df["am"] = df["am"].astype(str)
df["vs"] = df["vs"].astype(str)
df["gear"] = df["gear"].astype(str)
df["carb"] = df["carb"].astype(str)
df['cyl'] = df['cyl'].astype(str)

```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 497}
#figure 1
#density plot
from plotnine import geom_density, labs

(ggplot(df,
        aes(x='mpg', fill='cyl'))
+geom_density()
+labs(title='%age of miles per gallon based on cylendar counts',
        subtitle='Distribution of Fuel Efficiency by Engine Size',
        x='Miles Per Gallon (MPG)',
        y='Density'
      )
)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 497}
#figure 2
#comparing 3 varibale(displacement, no. of forward gear, miles per gallon)
from plotnine import ggplot, aes, geom_point, labs
from plotnine.data import mtcars

(
    ggplot(mtcars, aes(x='disp', y='mpg', size='gear', fill='gear'))
    + geom_point(alpha=0.4)
    + labs(title="Bubble Plot of Car Performance",
        x="Engine Displacement (cu. in.)",
        y="Miles Per Gallon (MPG)",
        size="Number of forward gears " # Set the legend title for size
    )
)
#cars with more forward gears (larger bubbles) tend to be more fuel-efficient(-ve correlation between displacement and MPG)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 515}
#figure 3

from plotnine import geom_violin
ggplot(df, aes(x="wt", y="mpg", fill='cyl')) + geom_violin()

#the violin graph shows the distribution of Miles Per Gallon (MPG) for different categories of Car Weight (wt), grouped by (cyl)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 497}
#figure 4

from plotnine import ggplot, aes, geom_col

(
    ggplot(df, aes(x="cyl", y="disp", fill='cyl'))
    + geom_col()
)
#bar chart shows the total engine displacement (disp) is highest for 8-cylinder cars and lowest for 4-cylinder cars across all cars in the dataset.
```

```{python}

```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 497}
# figure 1
#a line graph with points displaying the relationship of dispplacemet('dips') with miles per gallon('mpg')
from plotnine import geom_line, geom_point

(ggplot(df,
        aes(x='disp',
            y='mpg'

))
 + geom_point()
 + geom_line()
 )
#as engine displacement (disp) increases, miles per gallon (mpg) generally decreases (-ve correlation)
```

